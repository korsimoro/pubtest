<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>LD Signature Format Alignment - RWoT DIR Launchpad</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "LD Signature Format Alignment", url: "#_top", children: [
              {title: "Abstract", url: "#abstract" },
              {title: "Status", url: "#status" },
              {title: "Next Steps", url: "#next-steps" },
          ]},
          {title: "Implementing the 2017 RSA Signature Suite in a LD signature library", url: "#implementing-the-2017-rsa-signature-suite-in-a-ld-signature-library", children: [
              {title: "Source of Truth", url: "#source-of-truth" },
              {title: "LD signature flow", url: "#ld-signature-flow" },
              {title: "Steps to Verify", url: "#steps-to-verify" },
              {title: "Problems Encountered", url: "#problems-encountered" },
              {title: "Reference: Modifications to javascript JSON-LD signature library to support 2017 RSA Signature Suite", url: "#reference-modifications-to-javascript-json-ld-signature-library-to-support-2017-rsa-signature-suite" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <h1 id="ld-signature-format-alignment">LD Signature Format Alignment</h1>
<p>By Kim Hamilton Duffy, Rodolphe Marques, Markus Sabadello, Manu Sporny</p>
<h2 id="abstract">Abstract</h2>
<p>The goal of the "LD Signature Format Alignment" Working Group at Rebooting the Web of Trust IV was to investigate the feasibility and impact of the proposed <a href="https://w3c-dvcg.github.io/lds-rsa2017/">2017 RSA Signature Suite</a> spec, which brings JSON-LD signatures into alignment with the JOSE JSON Web Signature (JWS) standards.</p>
<p>The 2017 RSA Signature Suite is based on <a href="https://tools.ietf.org/html/rfc7797">RFC 7797</a>, the JSON Web Signature (JWS) Unencoded Payload Option specification. These unencoded payload options avoid <a href="https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust-fall2016/blob/master/topics-and-advance-readings/blockchain-extensions-for-linked-data-signatures.md">past concerns about the use of JWS</a> and achieve the following:</p>
<ul>
<li>Re-uses a signature format that has already been approved by IETF, and therefore no new security review is needed</li>
<li>Digitally signs JSON</li>
<li>Digitally signs Linked Data</li>
<li>Avoids base64 encodings of the payload (through the unencoded payload option)</li>
<li>Re-uses the same signature format that Verifiable Claims use</li>
</ul>
<p>Our working group had two primary questions about the proposed 2017 RSA Signature Suite:</p>
<ol>
<li>Is the specification sufficiently clear for implementors?</li>
<li>Is there a negative usability impact to LD signature implementations using this signature suite?</li>
</ol>
<p>To answer these questions, we developed prototypes for the suite in several key programming languages to assess:</p>
<ul>
<li>Availability of library support for JWS unencoded payload options</li>
<li>Impact to existing LD signature implementations, e.g. <a href="https://github.com/digitalbazaar/jsonld-signatures">jsonld-signatures library</a></li>
<li>Impact to usability of Verifiable Claims (and others) using JSON-LD signatures with this signature suite.</li>
</ul>
<h2 id="status">Status</h2>
<p>We accomplished our goals as follows:</p>
<ol>
<li>We delivered prototypes for the 2017 RSA Signature Suite that provided sufficient confidence to move forward with the proposed aligned signature approach. </li>
<li>We verified that there was no significant impact to existing LD signature implementations â€” and usability in general. Specifically, use of the unencoded payload option avoids the requirement of preserving the original binary form of the payload.</li>
</ol>
<p>The major obstacle we encountered while performing this work was the lack of JSON Web Signature library support for unencoded payloads, which is addressed in "Next Steps".</p>
<h3 id="implementations-of-ld-jws-signing">Implementations of LD JWS signing</h3>
<p>The following prototypes were developed:</p>
<ul>
<li>For Javascript/Node.js: https://github.com/WebOfTrustInfo/ld-signatures-js (this is a fork of JSON-LD signatures official library)</li>
<li>For Python: https://github.com/WebOfTrustInfo/jsonld-signatures-python (TODO: pending rename)</li>
<li>For Java: https://github.com/WebOfTrustInfo/ld-signatures-java</li>
</ul>
<h3 id="json-ld-jws-implementation-guidance-cross-platform">JSON-LD JWS Implementation Guidance (cross-platform)</h3>
<p>A white paper, which follows, describes the precise differences between existing LD signatures and the new approach.</p>
<h2 id="next-steps">Next Steps</h2>
<p>The primary gap in developing these prototypes, which accounted for most of our development work, was lack of library support for JWS unencoded payloads. To work around this limitation, our implementations mirrored the only implementation we found, available in the <a href="https://github.com/Spomky-Labs/josePHP">JOSE PHP library</a>. </p>
<p>A cleaner solution that we propose is to recraft our prototypes as JWS unencoded payload libraries. Such a library would expose simple sign-and-verify APIs, for example:</p>
<pre><code>signature = sign(headers: JSON, payload: STRING);
</code></pre>

<p>In this example, payload is assumed to be a detached payload, as described in <a href="https://tools.ietf.org/html/rfc7797">RFC 7797</a>.</p>
<p>This library would facilitate minimal changes to existing JSON-LD signature implementations.</p>
<h3 id="detailed-list-of-next-steps">Detailed List of Next Steps</h3>
<ul>
<li>Determine how to address problem that JWS implementations lack support for RFC 7797:</li>
<li>Recraft prototypes as JWS detached-signature libraries to provide a RFC 7797 implementation (with a least RS256) to either be merged into official JWS libraries or to act as standalone bridges until official support is provided.</li>
<li>Double-check end-to-end samples with RS256 algorithm (not provided in RFC 7797 or PHP tests).</li>
<li>Add 2017 RSA Signature suite to JSON-LD signature libraries, consuming JWS detached payload implementation.</li>
</ul>
<p>==========================================================================================================================================</p>
<h1 id="implementing-the-2017-rsa-signature-suite-in-a-ld-signature-library">Implementing the 2017 RSA Signature Suite in a LD signature library</h1>
<p>By Kim Hamilton Duffy, Rodolphe Marques, Markus Sabadello</p>
<p>This document describes specific steps and issues with implementing the 2017 RSA Signature Suite in an existing LD signature library.</p>
<h2 id="source-of-truth">Source of Truth</h2>
<p>RFC 7797 does not include an RS256 testcase, so we created a detached payload / RS256 unit test to obtain a source of truth using the JOSE <a href="https://github.com/Spomky-Labs/jose">implementation</a> (PHP) that implements the RFC 7797 spec.</p>
<pre><code class="php">
    public function testCompactJSONWithUnencodedDetachedPayloadRS256()
    {
        $payload = '$.02';
        $protected_header = [
            'alg'  =&gt; 'RS256',
            'b64'  =&gt; false,
            'crit' =&gt; ['b64'],
        ];

        $key = JWKFactory::createFromKeyFile(
            __DIR__.'/../Unit/Keys/RSA/private.encrypted.key',
            'tests', // password for key
            [
                'kid' =&gt; 'My Private RSA key',
                'use' =&gt; 'sig',
            ] // these options do not affect outcome of this test
        );

        $jws = JWSFactory::createJWSWithDetachedPayloadToCompactJSON($payload, $key, $protected_header);
        $this-&gt;assertEquals('eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..fZRkjTTrcXdUovHjghM6JvlMhJuR1s8X1F4Uy_F4oMhZ9KtF2Zp78lYSOI7OxB5uoTu8FpQHvy-dz3N4nLhoSWAi2_HrxZG_2DyctUUB_8pRKYBmIdIgpOlEMjIreOvXyM6A32gR-PdbzoQq14yQbbfxk12jyZSwcaNu29gXnW_uO7ku1GSV_juWE5E_yIstvEB1GG8ApUGIuzRJDrAAa8KBkHN7Rdfhc8rJMOeSZI0dc_A-Y7t0M0RtrgvV_FhzM40K1pwr1YUZ5y1N4QV13M5u5qJ_lBK40WtWYL5MbJ58Qqk_-Q8l1dp6OCmoMvwdc7FmMsPigmyklqo46uyjjw', $jws);


        $loader = new Loader();
        $loaded = $loader-&gt;loadAndVerifySignatureUsingKeyAndDetachedPayload(
            $jws,
            $key,
            ['RS256'],
            $payload,
            $index
        );

        $this-&gt;assertInstanceOf(JWSInterface::class, $loaded);
        $this-&gt;assertEquals(0, $index);
        $this-&gt;assertEquals($protected_header, $loaded-&gt;getSignature(0)-&gt;getProtectedHeaders());

    }

</code></pre>

<p>Note this test uses the <code>{"alg":"RS256","b64":false,"crit":["b64"]}</code> header and <code>$.02</code> as the unencoded payload.</p>
<p>The input of the signing function should match <code>eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19.$.02</code>
and the resulting signature should match <code>eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..fZRkjTTrcXdUovHjghM6JvlMhJuR1s8X1F4Uy_F4oMhZ9KtF2Zp78lYSOI7OxB5uoTu8FpQHvy-dz3N4nLhoSWAi2_HrxZG_2DyctUUB_8pRKYBmIdIgpOlEMjIreOvXyM6A32gR-PdbzoQq14yQbbfxk12jyZSwcaNu29gXnW_uO7ku1GSV_juWE5E_yIstvEB1GG8ApUGIuzRJDrAAa8KBkHN7Rdfhc8rJMOeSZI0dc_A-Y7t0M0RtrgvV_FhzM40K1pwr1YUZ5y1N4QV13M5u5qJ_lBK40WtWYL5MbJ58Qqk_-Q8l1dp6OCmoMvwdc7FmMsPigmyklqo46uyjjw</code></p>
<p>Our prototypes successfully matched this testcase, and matched results on JSON-LD claim inputs.</p>
<h2 id="ld-signature-flow">LD signature flow</h2>
<h3 id="overview">Overview</h3>
<p>The signing flow for the 2017 RSA Signature Suite is identical to other signature suites in the <a href="https://github.com/digitalbazaar/jsonld-signatures">JSON-LD signature library</a>; the processing required to implement 2017 RSA Signatures is confined to step #5 bolded below (all other steps are unchanged). A new algorithm, <code>RsaSignature2017</code>, was added to implement this signature suite.</p>
<p>The LD signature algorithm works as follows:</p>
<p>Inputs:
- JSON-LD headers (nonce, created, creator, ...) same as before, algorithm should be <code>RsaSignature2017</code> 
- JSON-LD document</p>
<p>JSON-LD Signing Algorithm:</p>
<ol>
<li>Ensure algorithm is in accepted set</li>
<li>Add <code>created</code> date of now, if not supplied</li>
<li>Canonicalize using the <code>GCA2015</code> algorithm, as specified in the 2017 RSA Signature Suite specification (NOTE: <code>GCA2015</code> was formerly called <code>URDNA2015</code>)</li>
<li>Prepend the JSON-LD signature options <code>date</code>, <code>domain</code>, <code>nonce</code> to the input to sign, as implemented in the <code>_getDataToHash</code> method of the JSON-LD signature library</li>
<li><strong>Sign with the 2017 RSA Signature Suite</strong> (details in next section)</li>
<li>Compact the signature</li>
</ol>
<p>Outputs:
- JSON-LD document with the signature block added</p>
<h3 id="signing-with-the-2017-rsa-signature-suite">Signing with the 2017 RSA Signature Suite</h3>
<p>This section drills into step #5 above.</p>
<p>To extend the <a href="https://github.com/digitalbazaar/jsonld-signatures">JSON-LD signature library</a> to support the 2017 RSA Signature Suite, we added a new algorithm type -- <code>RsaSignature2017</code> -- and a new processing case for this type in the function <code>createSignature</code>.</p>
<p>First, suppose a JWS library with unencoded payload support were available. If so, then the steps would be:</p>
<ol>
<li>Form the JWS Headers</li>
</ol>
<p>Per <a href="https://tools.ietf.org/html/rfc7797">RFC 7797</a>, creating a JWS signature using the unencoded payload option requires the JWS Header parameters <code>"b64":false</code> and <code>"crit":["b64"]</code>. In addition to these parameters, <code>RsaSignature2017</code> specifies using RSA Signatures with SHA-256. This corresponds to a JWS signing algorithm of <code>RS256</code>.</p>
<p>In sum the complete set of JWS headers used for a 2017 RSA Signature is:</p>
<pre><code>{
    &quot;alg&quot;:&quot;RS256&quot;,
    &quot;b64&quot;:false,
    &quot;crit&quot;:[&quot;b64&quot;]
}
</code></pre>

<ol>
<li>Call the JWS library with headers from #1 (parameter 1: <code>headers</code>) and the JSON-LD canonicalized payload (parameter 2: <code>payload</code>)</li>
</ol>
<pre><code>result = sign(headers: JSON, payload: STRING);
</code></pre>

<ol>
<li>Update the LD <code>signature</code> block to contain <code>signatureValue=&lt;result&gt;</code></li>
</ol>
<h4 id="implementing-jws-unencoded-payload-signing">Implementing JWS unencoded payload signing</h4>
<p>In step #2 above, we assumed the availabilty of a JWS library supporting unencoded payloads. Because we only found a PHP library supporting unencoded payloads, we needed to reimplement those steps.</p>
<p>Per <a href="https://tools.ietf.org/html/rfc7797">RFC 7797</a>, when the <code>b64</code> header parameter is used, it must be integrity protected. Therefore it must occur within the JWS Protected Header (meaning it is part of the input that is signed). Also, per RFC7797, the expected input to sign is formatted as follows:</p>
<p><code>ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || JWS Payload</code></p>
<p>In our case, <code>JWS Payload</code> is the normalized JSON-LD.</p>
<p>This yields the following steps:</p>
<ol>
<li>Format the input to sign: <ol>
<li>Stringify the protected header JSON, sorting the keys. <ul>
<li>Note: sorting the protected header parameters is an implementation choice to allow predictability. Since the original JWS header can be obtained from the JWS signature prefix, verification could simply ensure it encodes the JWS headers in the same order.</li>
</ul>
</li>
<li>Encode the stringified header as follows:<ol>
<li>utf-8 encode</li>
<li>base64 url encode</li>
<li>ascii encode</li>
</ol>
</li>
<li>Form the JWS input to sign as <code>&lt;header&gt; + "." + &lt;payload&gt;</code><ul>
<li>The critical distinction here is that <code>payload</code> is not base64 encoded, per the b64=false argument. </li>
</ul>
</li>
</ol>
</li>
<li>Sign:<ol>
<li>RSASHA256-sign the JWS input</li>
<li>base64-url-encode the signature value</li>
</ol>
</li>
<li>Return the signature result <code>&lt;header&gt; + ".." + &lt;base64Signature&gt;</code>:<ul>
<li>The <code>..</code> indicates a JWS detached payload. Note that typically in in JWS, the payload be between the middle 2 dots.</li>
</ul>
</li>
</ol>
<h2 id="steps-to-verify">Steps to Verify</h2>
<p>The verification algorithm has not yet been implemented, so this is just a tentative description of what should happen:</p>
<ol>
<li>Remove the <code>signature</code> from the JSON-LD document.</li>
<li>Normalize the resulting JSON-LD document (without the <code>signatureValue</code> key).</li>
<li>SHA256-hash the normalized JSON-LD.</li>
<li>Use the hash and the payload as inputs to JWS verification algorithm.</li>
</ol>
<h2 id="problems-encountered">Problems Encountered</h2>
<h3 id="lack-of-jws-detached-payload-library-support">Lack of JWS detached payload library support</h3>
<p>As described above, the only library we found that supports detached payloads was the <a href="https://github.com/Spomky-Labs/jose">PHP JOSE</a> library. </p>
<h3 id="inconsistent-ordering-of-jws-headers">Inconsistent ordering of JWS headers</h3>
<p>To our knowledge the JOSE specs do not specify how JSON headers should be ordered. In our implementations, we ensured consistent lexicographical sorting of JWS headers. This is not critical since the encoded header is included in the signature, but our goal was to produce consistent signatures (similar to what's done in <code>_getDataToHash</code>.</p>
<p>Specifying the sorting of the keys, the separators and the encoding should be enough for any implementation to be able to produce the same signature.</p>
<p>Example in python:</p>
<pre><code class="python">import json

header = {'alg': 'RS256', 'b64': False, 'crit': ['b64']}

# stringify json
# there are no guarantees about the ordering of the keys and the separators use
# a whitespace between the keys
json.dumps(header)
'{&quot;crit&quot;: [&quot;b64&quot;], &quot;alg&quot;: &quot;RS256&quot;, &quot;b64&quot;: false}'

# we can specify the separators. In this case we say we don't want whitespaces
json.dumps(header, separators=(',', ':'))
'{&quot;crit&quot;:[&quot;b64&quot;],&quot;alg&quot;:&quot;RS256&quot;,&quot;b64&quot;:false}'

# and we can specify the ordering of the keys
json.dumps(header, separators=(',', ':'), sort_keys=True)
'{&quot;alg&quot;:&quot;RS256&quot;,&quot;b64&quot;:false,&quot;crit&quot;:[&quot;b64&quot;]}'

# ultimately we can specify the encoding to use and return a bytestring that
can then be used to base64 encode / sign / hash
json.dumps(header, separators=(',', ':'), sort_keys=True).encode('utf-8')
b'{&quot;alg&quot;:&quot;RS256&quot;,&quot;b64&quot;:false,&quot;crit&quot;:[&quot;b64&quot;]}'
</code></pre>

<h2 id="reference-modifications-to-javascript-json-ld-signature-library-to-support-2017-rsa-signature-suite">Reference: Modifications to javascript JSON-LD signature library to support 2017 RSA Signature Suite</h2>
<p>The <a href="https://github.com/WebOfTrustInfo/ld-signatures-js">ld-signatures-js repo</a> contains the 2017 RSA Signature Suite prototype</p>
<p>The modifications are:
- Add new algorithm type <code>RsaSignature2017</code>
- Add new paths to <code>_createSignature</code> to support <code>RsaSignature2017</code> (Node.js and Javascript environments)
- Add new paths to <code>_verifySignature</code> to support <code>RsaSignature2017</code> (Node.js and Javascript environments)</p>
<p>For example, the inlined implementation of <code>_createSignature</code> with algorithm <code>RsaSignature2017</code> (Node.js environment) is:</p>
<pre><code>var crypto = api.use('crypto');
var signer = crypto.createSign('RSA-SHA256');

// detached signature headers for JWS
var protectedHeader = {&quot;alg&quot;:&quot;RS256&quot;,&quot;b64&quot;:false,&quot;crit&quot;:[&quot;b64&quot;]};

var stringifiedHeader = JSON.stringify(protectedHeader, Object.keys(protectedHeader).sort());
var b64UrlEncodedHeader = base64url.encode(stringifiedHeader);

// jws input to sign
var to_sign = b64UrlEncodedHeader + &quot;.&quot; + _getDataToHash(input, options);

// sign
signer.update(to_sign, 'utf-8');
var signaturePart = signer.sign(options.privateKeyPem, 'base64');

// JWS signature for unencoded payload is: &lt;b64UrlEncodedHeader&gt; + '..' + &lt;signaturePath&gt;
var signature = b64UrlEncodedHeader + &quot;..&quot; + signaturePart;
</code></pre>

<p><strong>Reminder</strong> This inlined version is to demonstrate the computations performed. It includes steps that should be performed by a JWS library supporting unencoded payloads. The <a href="https://github.com/WebOfTrustInfo/ld-signatures-js">ld-signatures-js repo</a> factors these parts out as separate functions, but should ultimately be replaced by a proper JWS library supporting unencoded payloads, when a javascript implementation exists.</p>
<p>https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust-spring2017/blob/master/topics-and-advance-readings/SignatureFormatAlignment.md</p>

  <br>
</div>

<footer class="col-md-12 wm-page-content"><p>All of the contents of this directory are licensed CC-BY their contributors, unless otherwise noted.</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>